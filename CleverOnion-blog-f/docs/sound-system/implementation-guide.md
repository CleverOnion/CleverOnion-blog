# å®ç°æŒ‡å—

æœ¬æ–‡æ¡£æä¾›éŸ³æ•ˆç³»ç»Ÿçš„å®Œæ•´å®ç°æ­¥éª¤ï¼Œä»é›¶å¼€å§‹æ„å»ºæ•´ä¸ªç³»ç»Ÿã€‚

---

## ğŸ“Œ ä½¿ç”¨è¯´æ˜

### çŠ¶æ€æ ‡è®°è¯´æ˜

æœ¬æ–‡æ¡£ä½¿ç”¨ä»¥ä¸‹æ ‡è®°æ¥è·Ÿè¸ªå®ç°è¿›åº¦ï¼š

- **â¬œ æœªå¼€å§‹**ï¼šä»»åŠ¡å°šæœªå¼€å§‹
- **â—»ï¸ è¿›è¡Œä¸­**ï¼šä»»åŠ¡æ­£åœ¨è¿›è¡Œ
- **âœ… å·²å®Œæˆ**ï¼šä»»åŠ¡å·²å®Œæˆ

### å¦‚ä½•ä½¿ç”¨

1. **å¼€å§‹ä»»åŠ¡æ—¶**ï¼šå°†æ­¥éª¤æ ‡é¢˜çš„ â¬œ æ›´æ”¹ä¸º â—»ï¸ï¼Œå¹¶æ›´æ–°çŠ¶æ€è¡Œ
2. **å®Œæˆä»»åŠ¡æ—¶**ï¼šå°†æ­¥éª¤æ ‡é¢˜çš„ â—»ï¸ æ›´æ”¹ä¸º âœ…ï¼Œå¹¶æ›´æ–°çŠ¶æ€è¡Œå’Œé¡¶éƒ¨è¿›åº¦è¿½è¸ªçš„ checkbox
3. **è·Ÿè¸ªæ€»ä½“è¿›åº¦**ï¼šæŸ¥çœ‹é¡¶éƒ¨çš„è¿›åº¦è¿½è¸ªåˆ—è¡¨

**ç¤ºä¾‹**ï¼š

```markdown
### æ­¥éª¤ 1: åˆ›å»ºç±»å‹å®šä¹‰ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… å·²å®Œæˆ
```

---

## ğŸ“‹ å®ç°æ­¥éª¤æ¦‚è§ˆ

### è¿›åº¦è¿½è¸ª

**Phase 1: åŸºç¡€æ¶æ„**

- [x] 1. åˆ›å»ºç±»å‹å®šä¹‰
- [x] 2. å®ç° SoundEngineï¼ˆéŸ³æ•ˆå¼•æ“ï¼‰
- [x] 3. å®ç° SoundConfigManagerï¼ˆé…ç½®ç®¡ç†ï¼‰
- [x] 4. å®ç° SoundManagerï¼ˆéŸ³æ•ˆç®¡ç†ï¼‰
- [x] 5. åˆ›å»ºå…¥å£æ–‡ä»¶

**Phase 2: é›†æˆåº”ç”¨**

- [x] 6. é›†æˆåˆ° API æ‹¦æˆªå™¨
- [x] 7. åº”ç”¨åˆå§‹åŒ–
- [x] 8. åˆ›å»ºç”¨æˆ·è®¾ç½® UI

**Phase 3: æµ‹è¯•ä¼˜åŒ–**

- [ ] 9. åŠŸèƒ½æµ‹è¯•
- [ ] 10. æ€§èƒ½ä¼˜åŒ–

---

### å®ç°è·¯çº¿å›¾

```
Phase 1: åŸºç¡€æ¶æ„
â”œâ”€â”€ 1. åˆ›å»ºç±»å‹å®šä¹‰
â”œâ”€â”€ 2. å®ç° SoundEngineï¼ˆéŸ³æ•ˆå¼•æ“ï¼‰
â”œâ”€â”€ 3. å®ç° SoundConfigManagerï¼ˆé…ç½®ç®¡ç†ï¼‰
â”œâ”€â”€ 4. å®ç° SoundManagerï¼ˆéŸ³æ•ˆç®¡ç†ï¼‰
â””â”€â”€ 5. åˆ›å»ºå…¥å£æ–‡ä»¶

Phase 2: é›†æˆåº”ç”¨
â”œâ”€â”€ 6. é›†æˆåˆ° API æ‹¦æˆªå™¨
â”œâ”€â”€ 7. åº”ç”¨åˆå§‹åŒ–
â””â”€â”€ 8. åˆ›å»ºç”¨æˆ·è®¾ç½® UI

Phase 3: æµ‹è¯•ä¼˜åŒ–
â”œâ”€â”€ 9. åŠŸèƒ½æµ‹è¯•
â””â”€â”€ 10. æ€§èƒ½ä¼˜åŒ–
```

---

## Phase 1: åŸºç¡€æ¶æ„

### æ­¥éª¤ 1: åˆ›å»ºç±»å‹å®šä¹‰ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/utils/sound/types.ts`ï¼š

```typescript
/**
 * éŸ³æ•ˆç³»ç»Ÿç±»å‹å®šä¹‰
 */

// éŸ³æ•ˆä¼˜å…ˆçº§
export enum SoundPriority {
  Low = 0, // ä½ä¼˜å…ˆçº§
  Normal = 1, // æ™®é€šä¼˜å…ˆçº§
  High = 2, // é«˜ä¼˜å…ˆçº§
  Critical = 3, // å…³é”®ä¼˜å…ˆçº§
}

// é¢„è®¾é…ç½®åç§°
export enum PresetName {
  Silent = "silent",
  ErrorsOnly = "errors-only",
  Minimal = "minimal",
  Standard = "standard",
  Full = "full",
}

// æ’­æ”¾é€‰é¡¹
export interface PlayOptions {
  volume?: number; // éŸ³é‡ 0.0-1.0
  priority?: SoundPriority; // ä¼˜å…ˆçº§
  force?: boolean; // å¼ºåˆ¶æ’­æ”¾ï¼Œå¿½ç•¥èŠ‚æµ
  delay?: number; // å»¶è¿Ÿæ’­æ”¾ï¼ˆæ¯«ç§’ï¼‰
}

// åœºæ™¯é…ç½®
export interface SceneConfig {
  enabled: boolean;
  volume?: number;
  priority?: SoundPriority;
  soundFile?: string;
}

// åˆ†ç±»é…ç½®
export interface CategoryConfig {
  enabled: boolean;
  volume: number;
  throttle: number;
  scenes: Record<string, SceneConfig>;
}

// å®Œæ•´é…ç½®
export interface SoundConfig {
  version: string;
  master: {
    enabled: boolean;
    volume: number;
    respectSystemSettings: boolean;
  };
  categories: Record<string, CategoryConfig>;
}

// ç»Ÿè®¡ä¿¡æ¯
export interface SoundStats {
  totalPlayed: number;
  throttled: number;
  cacheHits: number;
  cacheMisses: number;
}

// èŠ‚æµçŠ¶æ€
export interface ThrottleState {
  lastPlayTime: number;
  playCount: number;
}
```

---

### æ­¥éª¤ 2: å®ç° SoundEngineï¼ˆéŸ³æ•ˆå¼•æ“ï¼‰ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/utils/sound/SoundEngine.ts`ï¼š

```typescript
/**
 * éŸ³æ•ˆå¼•æ“ - è´Ÿè´£åº•å±‚éŸ³é¢‘æ’­æ”¾
 */

export class SoundEngine {
  private audioContext: AudioContext | null = null;
  private gainNode: GainNode | null = null;
  private bufferCache: Map<string, AudioBuffer> = new Map();
  private stats = {
    cacheHits: 0,
    cacheMisses: 0,
  };

  /**
   * åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
   */
  init(): void {
    if (this.audioContext) return;

    try {
      this.audioContext = new (window.AudioContext ||
        (window as any).webkitAudioContext)();

      this.gainNode = this.audioContext.createGain();
      this.gainNode.connect(this.audioContext.destination);
    } catch (error) {
      console.warn("éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥:", error);
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æ”¯æŒ
   */
  isSupported(): boolean {
    return (
      typeof AudioContext !== "undefined" ||
      typeof (window as any).webkitAudioContext !== "undefined"
    );
  }

  /**
   * åŠ è½½éŸ³é¢‘æ–‡ä»¶
   */
  async loadSound(url: string): Promise<AudioBuffer | null> {
    // æ£€æŸ¥ç¼“å­˜
    if (this.bufferCache.has(url)) {
      this.stats.cacheHits++;
      return this.bufferCache.get(url)!;
    }

    this.stats.cacheMisses++;

    if (!this.audioContext) {
      this.init();
    }

    if (!this.audioContext) {
      console.warn("éŸ³é¢‘ä¸Šä¸‹æ–‡ä¸å¯ç”¨");
      return null;
    }

    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

      // ç¼“å­˜
      this.bufferCache.set(url, audioBuffer);

      return audioBuffer;
    } catch (error) {
      console.warn(`éŸ³é¢‘åŠ è½½å¤±è´¥: ${url}`, error);
      return null;
    }
  }

  /**
   * æ’­æ”¾éŸ³é¢‘
   */
  async play(buffer: AudioBuffer, volume: number = 1.0): Promise<void> {
    if (!this.audioContext || !this.gainNode) {
      this.init();
    }

    if (!this.audioContext || !this.gainNode) {
      return;
    }

    try {
      // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆæµè§ˆå™¨å¯èƒ½ä¼šæš‚åœï¼‰
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }

      const source = this.audioContext.createBufferSource();
      source.buffer = buffer;

      // åˆ›å»ºéŸ³é‡èŠ‚ç‚¹
      const gainNode = this.audioContext.createGain();
      gainNode.gain.value = Math.max(0, Math.min(1, volume));

      // è¿æ¥éŸ³é¢‘å›¾
      source.connect(gainNode);
      gainNode.connect(this.gainNode);

      // æ’­æ”¾
      source.start(0);
    } catch (error) {
      console.warn("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
    }
  }

  /**
   * è®¾ç½®ä¸»éŸ³é‡
   */
  setMasterVolume(volume: number): void {
    if (this.gainNode) {
      this.gainNode.gain.value = Math.max(0, Math.min(1, volume));
    }
  }

  /**
   * é¢„åŠ è½½éŸ³æ•ˆ
   */
  async preload(urls: string[]): Promise<void> {
    await Promise.all(urls.map((url) => this.loadSound(url)));
  }

  /**
   * æ¸…é™¤ç¼“å­˜
   */
  clearCache(): void {
    this.bufferCache.clear();
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return {
      cacheHits: this.stats.cacheHits,
      cacheMisses: this.stats.cacheMisses,
      cacheSize: this.bufferCache.size,
    };
  }
}
```

---

### æ­¥éª¤ 3: å®ç° SoundConfigManagerï¼ˆé…ç½®ç®¡ç†ï¼‰ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/utils/sound/SoundConfigManager.ts`ï¼š

```typescript
/**
 * éŸ³æ•ˆé…ç½®ç®¡ç†å™¨
 */

import type { SoundConfig, PresetName } from "./types";

export class SoundConfigManager {
  private static readonly STORAGE_KEY = "sound-system-config";
  private static readonly VERSION = "1.0.0";

  /**
   * è·å–é»˜è®¤é…ç½®
   */
  static getDefaultConfig(): SoundConfig {
    return {
      version: this.VERSION,
      master: {
        enabled: true,
        volume: 70,
        respectSystemSettings: true,
      },
      categories: {
        api: {
          enabled: true,
          volume: 50,
          throttle: 1000,
          scenes: {
            "api.success.get": {
              enabled: false,
              priority: 0, // Low
            },
            "api.success.post": {
              enabled: true,
              priority: 1, // Normal
            },
            "api.success.put": {
              enabled: true,
              priority: 1, // Normal
            },
            "api.success.patch": {
              enabled: true,
              priority: 1, // Normal
            },
            "api.success.delete": {
              enabled: true,
              priority: 2, // High
            },
            "api.error.400": {
              enabled: true,
              priority: 1, // Normal
            },
            "api.error.401": {
              enabled: true,
              priority: 2, // High
            },
            "api.error.403": {
              enabled: true,
              priority: 2, // High
            },
            "api.error.404": {
              enabled: true,
              priority: 1, // Normal
            },
            "api.error.4xx": {
              enabled: true,
              priority: 2, // High
            },
            "api.error.500": {
              enabled: true,
              priority: 3, // Critical
            },
            "api.error.503": {
              enabled: true,
              priority: 3, // Critical
            },
            "api.error.5xx": {
              enabled: true,
              priority: 3, // Critical
            },
            "api.error.timeout": {
              enabled: true,
              priority: 2, // High
            },
            "api.error.network": {
              enabled: true,
              priority: 3, // Critical
            },
          },
        },
      },
    };
  }

  /**
   * åŠ è½½é…ç½®
   */
  static load(): SoundConfig {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      if (!stored) {
        return this.getDefaultConfig();
      }

      const userConfig = JSON.parse(stored);
      return this.merge(this.getDefaultConfig(), userConfig);
    } catch (error) {
      console.warn("é…ç½®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:", error);
      return this.getDefaultConfig();
    }
  }

  /**
   * ä¿å­˜é…ç½®
   */
  static save(config: SoundConfig): void {
    try {
      config.version = this.VERSION;
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(config));
    } catch (error) {
      console.warn("é…ç½®ä¿å­˜å¤±è´¥:", error);
    }
  }

  /**
   * é‡ç½®é…ç½®
   */
  static reset(): SoundConfig {
    const defaultConfig = this.getDefaultConfig();
    this.save(defaultConfig);
    return defaultConfig;
  }

  /**
   * å¯¼å‡ºé…ç½®
   */
  static export(config: SoundConfig): string {
    return JSON.stringify(config, null, 2);
  }

  /**
   * å¯¼å…¥é…ç½®
   */
  static import(json: string): SoundConfig {
    try {
      const imported = JSON.parse(json);
      const merged = this.merge(this.getDefaultConfig(), imported);
      this.save(merged);
      return merged;
    } catch (error) {
      console.warn("é…ç½®å¯¼å…¥å¤±è´¥:", error);
      return this.getDefaultConfig();
    }
  }

  /**
   * è·å–é¢„è®¾é…ç½®
   */
  static getPreset(name: PresetName): SoundConfig {
    const base = this.getDefaultConfig();

    switch (name) {
      case "silent":
        return {
          ...base,
          master: { ...base.master, enabled: false, volume: 0 },
        };

      case "errors-only":
        return {
          ...base,
          categories: {
            api: {
              ...base.categories.api,
              scenes: {
                ...base.categories.api.scenes,
                "api.success.get": {
                  ...base.categories.api.scenes["api.success.get"],
                  enabled: false,
                },
                "api.success.post": {
                  ...base.categories.api.scenes["api.success.post"],
                  enabled: false,
                },
                "api.success.put": {
                  ...base.categories.api.scenes["api.success.put"],
                  enabled: false,
                },
                "api.success.patch": {
                  ...base.categories.api.scenes["api.success.patch"],
                  enabled: false,
                },
                "api.success.delete": {
                  ...base.categories.api.scenes["api.success.delete"],
                  enabled: false,
                },
              },
            },
          },
        };

      case "minimal":
        return {
          ...base,
          master: { ...base.master, volume: 50 },
          categories: {
            api: {
              ...base.categories.api,
              throttle: 2000,
              scenes: {
                ...base.categories.api.scenes,
                "api.success.get": {
                  ...base.categories.api.scenes["api.success.get"],
                  enabled: false,
                },
              },
            },
          },
        };

      case "full":
        return {
          ...base,
          master: { ...base.master, volume: 80 },
          categories: {
            api: {
              ...base.categories.api,
              volume: 70,
              throttle: 500,
              scenes: {
                ...base.categories.api.scenes,
                "api.success.get": {
                  ...base.categories.api.scenes["api.success.get"],
                  enabled: true,
                },
              },
            },
          },
        };

      case "standard":
      default:
        return base;
    }
  }

  /**
   * æ·±åº¦åˆå¹¶é…ç½®
   */
  private static merge(target: any, source: any): any {
    const result = { ...target };

    for (const key in source) {
      if (
        source[key] &&
        typeof source[key] === "object" &&
        !Array.isArray(source[key])
      ) {
        result[key] = this.merge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }

    return result;
  }
}
```

---

### æ­¥éª¤ 4: å®ç° SoundManagerï¼ˆéŸ³æ•ˆç®¡ç†ï¼‰ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/utils/sound/SoundManager.ts`ï¼š

```typescript
/**
 * éŸ³æ•ˆç®¡ç†å™¨ - ä¸»å…¥å£
 */

import { SoundEngine } from "./SoundEngine";
import { SoundConfigManager } from "./SoundConfigManager";
import type {
  SoundConfig,
  PlayOptions,
  PresetName,
  ThrottleState,
  SoundStats,
} from "./types";

export class SoundManager {
  private engine: SoundEngine;
  private config: SoundConfig;
  private throttleMap: Map<string, ThrottleState> = new Map();
  private stats = {
    totalPlayed: 0,
    throttled: 0,
  };
  private debugMode = false;
  private soundRegistry: Record<string, Record<string, string>> = {};

  constructor() {
    this.engine = new SoundEngine();
    this.config = SoundConfigManager.load();
  }

  /**
   * åˆå§‹åŒ–
   */
  init(): void {
    this.engine.init();
    this.log("éŸ³æ•ˆç³»ç»Ÿå·²åˆå§‹åŒ–");
  }

  /**
   * æ³¨å†ŒéŸ³æ•ˆæ–‡ä»¶
   */
  registerSounds(registry: Record<string, Record<string, string>>): void {
    this.soundRegistry = registry;
  }

  /**
   * æ’­æ”¾éŸ³æ•ˆ
   */
  async play(eventName: string, options?: PlayOptions): Promise<void> {
    // 1. æƒé™æ£€æŸ¥
    if (!this.shouldPlay(eventName, options)) {
      return;
    }

    // 2. èŠ‚æµæ£€æŸ¥
    if (!options?.force && !this.checkThrottle(eventName)) {
      this.stats.throttled++;
      this.log(`éŸ³æ•ˆè¢«èŠ‚æµ: ${eventName}`);
      return;
    }

    // 3. è·å–éŸ³æ•ˆæ–‡ä»¶è·¯å¾„
    const soundFile = this.getSoundFile(eventName);
    if (!soundFile) {
      this.log(`æœªæ‰¾åˆ°éŸ³æ•ˆæ–‡ä»¶: ${eventName}`);
      return;
    }

    // 4. è®¡ç®—éŸ³é‡
    const volume = this.calculateVolume(eventName, options);

    // 5. åŠ è½½å¹¶æ’­æ”¾
    try {
      const buffer = await this.engine.loadSound(soundFile);
      if (buffer) {
        if (options?.delay) {
          setTimeout(() => this.engine.play(buffer, volume), options.delay);
        } else {
          await this.engine.play(buffer, volume);
        }

        this.stats.totalPlayed++;
        this.log(`æ’­æ”¾éŸ³æ•ˆ: ${eventName}, éŸ³é‡: ${volume.toFixed(2)}`);
      }
    } catch (error) {
      console.warn(`éŸ³æ•ˆæ’­æ”¾å¤±è´¥: ${eventName}`, error);
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’­æ”¾
   */
  private shouldPlay(eventName: string, options?: PlayOptions): boolean {
    // å…¨å±€å¼€å…³
    if (!this.config.master.enabled) {
      return false;
    }

    // è·å–åˆ†ç±»
    const category = this.getCategory(eventName);
    if (!category) {
      return false;
    }

    // åˆ†ç±»å¼€å…³
    const categoryConfig = this.config.categories[category];
    if (!categoryConfig?.enabled) {
      return false;
    }

    // åœºæ™¯å¼€å…³
    const sceneConfig = categoryConfig.scenes[eventName];
    if (sceneConfig && !sceneConfig.enabled) {
      return false;
    }

    // ä¸Šä¸‹æ–‡æ£€æŸ¥
    if (!this.checkContext()) {
      return false;
    }

    return true;
  }

  /**
   * èŠ‚æµæ£€æŸ¥
   */
  private checkThrottle(eventName: string): boolean {
    const category = this.getCategory(eventName);
    if (!category) return true;

    const categoryConfig = this.config.categories[category];
    const throttleMs = categoryConfig?.throttle || 1000;

    const now = Date.now();
    const state = this.throttleMap.get(eventName);

    if (!state || now - state.lastPlayTime > throttleMs) {
      this.throttleMap.set(eventName, {
        lastPlayTime: now,
        playCount: 1,
      });
      return true;
    }

    return false;
  }

  /**
   * ä¸Šä¸‹æ–‡æ£€æŸ¥
   */
  private checkContext(): boolean {
    // æ£€æŸ¥æ ‡ç­¾é¡µå¯è§æ€§
    if (document.hidden) {
      return false;
    }

    // æ£€æŸ¥ç³»ç»Ÿè®¾ç½®
    if (this.config.master.respectSystemSettings) {
      const prefersReduced = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;
      if (prefersReduced) {
        return false;
      }
    }

    return true;
  }

  /**
   * è®¡ç®—éŸ³é‡
   */
  private calculateVolume(eventName: string, options?: PlayOptions): number {
    let volume = this.config.master.volume / 100;

    const category = this.getCategory(eventName);
    if (category) {
      const categoryConfig = this.config.categories[category];
      volume *= (categoryConfig?.volume || 100) / 100;

      const sceneConfig = categoryConfig?.scenes[eventName];
      if (sceneConfig?.volume !== undefined) {
        volume *= sceneConfig.volume / 100;
      }
    }

    if (options?.volume !== undefined) {
      volume *= options.volume;
    }

    return Math.max(0, Math.min(1, volume));
  }

  /**
   * è·å–éŸ³æ•ˆæ–‡ä»¶è·¯å¾„
   */
  private getSoundFile(eventName: string): string | null {
    const category = this.getCategory(eventName);
    if (!category) return null;

    // æ£€æŸ¥è‡ªå®šä¹‰éŸ³æ•ˆ
    const categoryConfig = this.config.categories[category];
    const sceneConfig = categoryConfig?.scenes[eventName];
    if (sceneConfig?.soundFile) {
      return sceneConfig.soundFile;
    }

    // ä»æ³¨å†Œè¡¨è·å–
    const action = eventName.split(".")[1]; // å¦‚ 'success' æˆ– 'error'
    return this.soundRegistry[category]?.[action] || null;
  }

  /**
   * è·å–åˆ†ç±»
   */
  private getCategory(eventName: string): string | null {
    const parts = eventName.split(".");
    return parts[0] || null;
  }

  /**
   * è®¾ç½®ä¸»éŸ³é‡
   */
  setMasterVolume(volume: number): void {
    this.config.master.volume = Math.max(0, Math.min(100, volume));
    this.engine.setMasterVolume(volume / 100);
    SoundConfigManager.save(this.config);
  }

  /**
   * è®¾ç½®å…¨å±€å¼€å…³
   */
  setEnabled(enabled: boolean): void {
    this.config.master.enabled = enabled;
    SoundConfigManager.save(this.config);
  }

  /**
   * è®¾ç½®åˆ†ç±»å¼€å…³
   */
  setCategoryEnabled(category: string, enabled: boolean): void {
    if (this.config.categories[category]) {
      this.config.categories[category].enabled = enabled;
      SoundConfigManager.save(this.config);
    }
  }

  /**
   * è®¾ç½®åœºæ™¯å¼€å…³
   */
  setSceneEnabled(eventName: string, enabled: boolean): void {
    const category = this.getCategory(eventName);
    if (category && this.config.categories[category]) {
      const scene = this.config.categories[category].scenes[eventName];
      if (scene) {
        scene.enabled = enabled;
        SoundConfigManager.save(this.config);
      }
    }
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): SoundConfig {
    return { ...this.config };
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig(partial: Partial<SoundConfig>): void {
    this.config = { ...this.config, ...partial };
    SoundConfigManager.save(this.config);
  }

  /**
   * é‡ç½®é…ç½®
   */
  resetConfig(): void {
    this.config = SoundConfigManager.reset();
  }

  /**
   * åŠ è½½é¢„è®¾
   */
  loadPreset(name: PresetName): void {
    this.config = SoundConfigManager.getPreset(name);
    SoundConfigManager.save(this.config);
  }

  /**
   * å¯¼å‡ºé…ç½®
   */
  exportConfig(): string {
    return SoundConfigManager.export(this.config);
  }

  /**
   * å¯¼å…¥é…ç½®
   */
  importConfig(json: string): void {
    this.config = SoundConfigManager.import(json);
  }

  /**
   * é¢„åŠ è½½éŸ³æ•ˆ
   */
  async preload(eventNames: string[]): Promise<void> {
    const urls: string[] = [];
    eventNames.forEach((eventName) => {
      const url = this.getSoundFile(eventName);
      if (url) urls.push(url);
    });

    await this.engine.preload(urls);
  }

  /**
   * æ£€æŸ¥æ”¯æŒ
   */
  isSupported(): boolean {
    return this.engine.isSupported();
  }

  /**
   * è®¾ç½®è°ƒè¯•æ¨¡å¼
   */
  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): SoundStats {
    const engineStats = this.engine.getStats();
    return {
      totalPlayed: this.stats.totalPlayed,
      throttled: this.stats.throttled,
      cacheHits: engineStats.cacheHits,
      cacheMisses: engineStats.cacheMisses,
    };
  }

  /**
   * æ—¥å¿—
   */
  private log(message: string): void {
    if (this.debugMode) {
      console.log(`[SoundManager] ${message}`);
    }
  }
}
```

---

### æ­¥éª¤ 5: åˆ›å»ºå…¥å£æ–‡ä»¶ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/utils/sound/index.ts`ï¼š

```typescript
/**
 * éŸ³æ•ˆç³»ç»Ÿå…¥å£
 */

import { SoundManager } from "./SoundManager";

// éŸ³æ•ˆæ–‡ä»¶æ³¨å†Œè¡¨
const SOUND_REGISTRY = {
  api: {
    success: "/src/assets/mp3/success.mp3",
    error: "/src/assets/mp3/fail.mp3",
  },
};

// åˆ›å»ºå…¨å±€å®ä¾‹
export const soundManager = new SoundManager();
soundManager.registerSounds(SOUND_REGISTRY);

// å¯¼å‡ºç±»å‹
export * from "./types";
export { SoundManager } from "./SoundManager";
```

---

## Phase 2: é›†æˆåº”ç”¨

### æ­¥éª¤ 6: é›†æˆåˆ° API æ‹¦æˆªå™¨ âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

ä¿®æ”¹ `src/api/index.ts`ï¼š

```typescript
import axios from "axios";
import type {
  AxiosInstance,
  InternalAxiosRequestConfig,
  AxiosResponse,
  AxiosError,
} from "axios";
import { soundManager } from "@/utils/sound"; // å¯¼å…¥éŸ³æ•ˆç®¡ç†å™¨

// ... å…¶ä»–ä»£ç  ...

// å“åº”æ‹¦æˆªå™¨
apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    // æˆåŠŸå“åº”
    const method = response.config.method?.toLowerCase() || "get";
    const eventName = `api.success.${method}`;
    soundManager.play(eventName);

    return response;
  },
  (error: AxiosError) => {
    // é”™è¯¯å“åº”
    let eventName = "api.error.network";

    if (error.response?.status) {
      const status = error.response.status;
      eventName = `api.error.${status}`;

      // ä¼˜å…ˆçº§è®¾ç½®
      const priority = status >= 500 ? "critical" : "high";
      soundManager.play(eventName, { priority });
    } else if (error.code === "ECONNABORTED") {
      soundManager.play("api.error.timeout", { priority: "high" });
    } else {
      soundManager.play("api.error.network", { priority: "critical" });
    }

    return Promise.reject(error);
  }
);
```

---

### æ­¥éª¤ 7: åº”ç”¨åˆå§‹åŒ– âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

ä¿®æ”¹ `src/main.tsx`ï¼š

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { soundManager } from "@/utils/sound";

// åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
document.addEventListener(
  "click",
  () => {
    soundManager.init();
  },
  { once: true }
);

// é¢„åŠ è½½å¸¸ç”¨éŸ³æ•ˆ
soundManager.preload(["api.success.post", "api.error.500"]);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

### æ­¥éª¤ 8: åˆ›å»ºç”¨æˆ·è®¾ç½® UI âœ…

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… **å·²å®Œæˆ**

åˆ›å»º `src/components/settings/SoundSettings.tsx`ï¼š

```typescript
import React, { useState } from "react";
import { soundManager, PresetName } from "@/utils/sound";

export function SoundSettings() {
  const [config, setConfig] = useState(soundManager.getConfig());

  const handleToggle = (enabled: boolean) => {
    soundManager.setEnabled(enabled);
    setConfig(soundManager.getConfig());
  };

  const handleVolumeChange = (volume: number) => {
    soundManager.setMasterVolume(volume);
    setConfig(soundManager.getConfig());

    // æ’­æ”¾ç¤ºä¾‹éŸ³æ•ˆ
    soundManager.play("api.success.post", { force: true });
  };

  const handlePresetChange = (preset: string) => {
    soundManager.loadPreset(preset as PresetName);
    setConfig(soundManager.getConfig());

    // æ’­æ”¾ç¤ºä¾‹éŸ³æ•ˆ
    soundManager.play("api.success.post", { force: true });
  };

  return (
    <div className="sound-settings">
      <h2>éŸ³æ•ˆè®¾ç½®</h2>

      <div className="setting-item">
        <label>
          <input
            type="checkbox"
            checked={config.master.enabled}
            onChange={(e) => handleToggle(e.target.checked)}
          />
          å¯ç”¨éŸ³æ•ˆ
        </label>
      </div>

      <div className="setting-item">
        <label>
          éŸ³é‡: {config.master.volume}%
          <input
            type="range"
            min="0"
            max="100"
            value={config.master.volume}
            onChange={(e) => handleVolumeChange(Number(e.target.value))}
            disabled={!config.master.enabled}
          />
        </label>
      </div>

      <div className="setting-item">
        <label>
          é¢„è®¾æ–¹æ¡ˆ:
          <select onChange={(e) => handlePresetChange(e.target.value)}>
            <option value="silent">é™éŸ³</option>
            <option value="errors-only">ä»…é”™è¯¯</option>
            <option value="minimal">æç®€</option>
            <option value="standard">æ ‡å‡†</option>
            <option value="full">å®Œæ•´</option>
          </select>
        </label>
      </div>
    </div>
  );
}
```

---

## Phase 3: æµ‹è¯•ä¼˜åŒ–

### æ­¥éª¤ 9: åŠŸèƒ½æµ‹è¯• â¬œ

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… å·²å®Œæˆ

åˆ›å»ºæµ‹è¯•æ–‡ä»¶ `src/utils/sound/__tests__/SoundManager.test.ts`ï¼š

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { SoundManager } from "../SoundManager";

describe("SoundManager", () => {
  let manager: SoundManager;

  beforeEach(() => {
    manager = new SoundManager();
  });

  it("åº”è¯¥åˆå§‹åŒ–", () => {
    expect(manager).toBeDefined();
    expect(manager.isSupported()).toBe(true);
  });

  it("åº”è¯¥åŠ è½½é»˜è®¤é…ç½®", () => {
    const config = manager.getConfig();
    expect(config.master.enabled).toBe(true);
    expect(config.master.volume).toBe(70);
  });

  it("åº”è¯¥è®¾ç½®ä¸»éŸ³é‡", () => {
    manager.setMasterVolume(50);
    const config = manager.getConfig();
    expect(config.master.volume).toBe(50);
  });

  it("åº”è¯¥åŠ è½½é¢„è®¾", () => {
    manager.loadPreset("silent");
    const config = manager.getConfig();
    expect(config.master.enabled).toBe(false);
  });
});
```

---

### æ­¥éª¤ 10: æ€§èƒ½ä¼˜åŒ– â¬œ

> **çŠ¶æ€**: â¬œ æœªå¼€å§‹ | â—»ï¸ è¿›è¡Œä¸­ | âœ… å·²å®Œæˆ

**ä¼˜åŒ–æ¸…å•**

1. **éŸ³æ•ˆæ–‡ä»¶ä¼˜åŒ–**

   - ä½¿ç”¨éŸ³é¢‘ç¼–è¾‘å·¥å…·ï¼ˆå¦‚ Audacityï¼‰å‹ç¼©æ–‡ä»¶
   - ç›®æ ‡å¤§å°ï¼š< 20KB
   - æ ¼å¼ï¼šMP3ï¼ˆ128kbpsï¼‰

2. **é¢„åŠ è½½ç­–ç•¥**

   ```typescript
   // åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½é«˜é¢‘éŸ³æ•ˆ
   soundManager.preload(["api.success.post", "api.error.500"]);
   ```

3. **èŠ‚æµé…ç½®**

   ```typescript
   // API åˆ†ç±»é»˜è®¤ 1 ç§’èŠ‚æµ
   throttle: 1000;
   ```

4. **å†…å­˜ç®¡ç†**
   ```typescript
   // å®šæœŸæ¸…ç†æœªä½¿ç”¨çš„ç¼“å­˜ï¼ˆå¯é€‰ï¼‰
   setInterval(() => {
     if (soundManager.getStats().cacheSize > 20) {
       soundManager.clearCache();
     }
   }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
   ```

---

## ğŸ”® æ‰©å±•æ–°éŸ³æ•ˆç±»å‹

### ç¤ºä¾‹ï¼šæ·»åŠ  UI äº¤äº’éŸ³æ•ˆ

**1. æ·»åŠ éŸ³æ•ˆæ–‡ä»¶**

```
src/assets/sounds/ui/
â”œâ”€â”€ click.mp3
â”œâ”€â”€ toggle.mp3
â””â”€â”€ swipe.mp3
```

**2. æ³¨å†ŒéŸ³æ•ˆ**

```typescript
// src/utils/sound/index.ts
const SOUND_REGISTRY = {
  api: { ... },
  interaction: {
    click: '/src/assets/sounds/ui/click.mp3',
    toggle: '/src/assets/sounds/ui/toggle.mp3',
    swipe: '/src/assets/sounds/ui/swipe.mp3'
  }
};
```

**3. æ·»åŠ é»˜è®¤é…ç½®**

```typescript
// src/utils/sound/SoundConfigManager.ts
categories: {
  api: { ... },
  interaction: {
    enabled: true,
    volume: 30,
    throttle: 100,
    scenes: {
      'interaction.click': { enabled: true, priority: 0 },
      'interaction.toggle': { enabled: true, priority: 1 }
    }
  }
}
```

**4. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨**

```typescript
import { soundManager } from "@/utils/sound";

function Button({ onClick, children }) {
  const handleClick = (e) => {
    soundManager.play("interaction.click");
    onClick?.(e);
  };

  return <button onClick={handleClick}>{children}</button>;
}
```

**å®Œæˆï¼** ğŸ‰

---

## ğŸ“Š æ€»ä½“è¿›åº¦æ¦‚è§ˆ

| Phase       | æ­¥éª¤                       | çŠ¶æ€ | å…³é”®æ£€æŸ¥ç‚¹                     |
| ----------- | -------------------------- | ---- | ------------------------------ |
| **Phase 1** | 1. åˆ›å»ºç±»å‹å®šä¹‰            | âœ…   | ç±»å‹å®šä¹‰æ–‡ä»¶åˆ›å»ºå®Œæˆ           |
| **Phase 1** | 2. å®ç° SoundEngine        | âœ…   | éŸ³é¢‘æ’­æ”¾ã€ç¼“å­˜åŠŸèƒ½æ­£å¸¸         |
| **Phase 1** | 3. å®ç° SoundConfigManager | âœ…   | é…ç½®åŠ è½½/ä¿å­˜/é¢„è®¾åŠŸèƒ½æ­£å¸¸     |
| **Phase 1** | 4. å®ç° SoundManager       | âœ…   | æ’­æ”¾ã€èŠ‚æµã€æƒé™æ£€æŸ¥åŠŸèƒ½æ­£å¸¸   |
| **Phase 1** | 5. åˆ›å»ºå…¥å£æ–‡ä»¶            | âœ…   | å¯¼å‡ºæ­£ç¡®ï¼ŒéŸ³æ•ˆæ³¨å†Œå®Œæˆ         |
| **Phase 2** | 6. é›†æˆåˆ° API æ‹¦æˆªå™¨       | âœ…   | API è¯·æ±‚æˆåŠŸ/å¤±è´¥æ—¶æ’­æ”¾éŸ³æ•ˆ    |
| **Phase 2** | 7. åº”ç”¨åˆå§‹åŒ–              | âœ…   | éŸ³æ•ˆç³»ç»Ÿæ­£ç¡®åˆå§‹åŒ–ï¼Œé¢„åŠ è½½å®Œæˆ |
| **Phase 2** | 8. åˆ›å»ºç”¨æˆ·è®¾ç½® UI         | âœ…   | è®¾ç½®é¢æ¿åŠŸèƒ½å®Œæ•´ï¼Œé…ç½®å¯ä¿å­˜   |
| **Phase 3** | 9. åŠŸèƒ½æµ‹è¯•                | â¬œ   | æ‰€æœ‰æµ‹è¯•é€šè¿‡                   |
| **Phase 3** | 10. æ€§èƒ½ä¼˜åŒ–               | â¬œ   | éŸ³æ•ˆæ–‡ä»¶ä¼˜åŒ–ï¼Œå†…å­˜ç®¡ç†è‰¯å¥½     |

**å®Œæˆåº¦**: 8 / 10 (80%) ğŸ‰ğŸ‰

---

## ğŸ“ è´¨é‡æ£€æŸ¥æ¸…å•

å®ç°å®Œæˆåè¿›è¡Œä»¥ä¸‹æ£€æŸ¥ï¼š

### åŠŸèƒ½å®Œæ•´æ€§

- [ ] æ‰€æœ‰ç±»å‹å®šä¹‰å®Œæ•´ä¸”æ­£ç¡®
- [ ] SoundEngine æ­£å¸¸å·¥ä½œï¼ˆåŠ è½½ã€æ’­æ”¾ã€ç¼“å­˜ï¼‰
- [ ] SoundConfigManager èƒ½ä¿å­˜/åŠ è½½é…ç½®
- [ ] SoundManager æ ¸å¿ƒåŠŸèƒ½æ­£å¸¸ï¼ˆæ’­æ”¾ã€èŠ‚æµã€ä¼˜å…ˆçº§ï¼‰
- [ ] API æ‹¦æˆªå™¨å·²é›†æˆå¹¶æ­£å¸¸è§¦å‘éŸ³æ•ˆ
- [ ] éŸ³æ•ˆæ–‡ä»¶å·²æ·»åŠ ä¸”è·¯å¾„æ­£ç¡®
- [ ] ç”¨æˆ·è®¾ç½® UI å·²åˆ›å»ºä¸”åŠŸèƒ½å®Œæ•´
- [ ] åº”ç”¨åˆå§‹åŒ–æ­£ç¡®ï¼ˆéŸ³é¢‘ä¸Šä¸‹æ–‡ã€é¢„åŠ è½½ï¼‰

### ç³»ç»ŸåŠŸèƒ½

- [ ] èŠ‚æµæœºåˆ¶ç”Ÿæ•ˆï¼ˆé˜²æ­¢éŸ³æ•ˆè¿‡äºé¢‘ç¹ï¼‰
- [ ] ä¼˜å…ˆçº§ç³»ç»Ÿå·¥ä½œï¼ˆé«˜ä¼˜å…ˆçº§ä¼˜å…ˆæ’­æ”¾ï¼‰
- [ ] ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ­£å¸¸ï¼ˆæ ‡ç­¾é¡µéšè—æ—¶ä¸æ’­æ”¾ï¼‰
- [ ] é…ç½®æŒä¹…åŒ–æ­£å¸¸ï¼ˆLocalStorage å­˜å‚¨ï¼‰
- [ ] é¢„è®¾åˆ‡æ¢åŠŸèƒ½æ­£å¸¸ï¼ˆ5 ç§é¢„è®¾å¯ç”¨ï¼‰

### æ€§èƒ½ä¸ä¼˜åŒ–

- [ ] æ€§èƒ½ä¼˜åŒ–å®Œæˆï¼ˆéŸ³æ•ˆæ–‡ä»¶ < 20KBï¼‰
- [ ] å†…å­˜ç®¡ç†è‰¯å¥½ï¼ˆç¼“å­˜åˆç†ï¼‰
- [ ] é¢„åŠ è½½ç­–ç•¥æœ‰æ•ˆï¼ˆå¸¸ç”¨éŸ³æ•ˆé¢„åŠ è½½ï¼‰
- [ ] æ— å†…å­˜æ³„æ¼

### ç”¨æˆ·ä½“éªŒ

- [ ] éŸ³æ•ˆéŸ³é‡åˆç†ï¼ˆé»˜è®¤é…ç½®èˆ’é€‚ï¼‰
- [ ] èŠ‚æµé—´éš”åˆé€‚ï¼ˆä¸ä¼šå¤ªåµï¼‰
- [ ] è®¾ç½®é¢æ¿æ˜“ç”¨ï¼ˆè°ƒæ•´æ–¹ä¾¿ï¼‰
- [ ] é”™è¯¯å¤„ç†å®Œå–„ï¼ˆéŸ³æ•ˆåŠ è½½å¤±è´¥ä¸å½±å“åŠŸèƒ½ï¼‰

### æ–‡æ¡£

- [ ] ä»£ç æ³¨é‡Šå®Œæ•´
- [ ] ç±»å‹å®šä¹‰å‡†ç¡®
- [ ] ä½¿ç”¨ç¤ºä¾‹æ¸…æ™°
- [ ] å®ç°è¿›åº¦å·²æ›´æ–°

---

## ğŸ› å¸¸è§é—®é¢˜

### 1. éŸ³æ•ˆæ— æ³•æ’­æ”¾

**åŸå› **: æµè§ˆå™¨è¦æ±‚ç”¨æˆ·äº¤äº’åæ‰èƒ½æ’­æ”¾éŸ³é¢‘

**è§£å†³**:

```typescript
// åœ¨ç”¨æˆ·é¦–æ¬¡ç‚¹å‡»æ—¶åˆå§‹åŒ–
document.addEventListener(
  "click",
  () => {
    soundManager.init();
  },
  { once: true }
);
```

### 2. éŸ³æ•ˆå»¶è¿Ÿ

**åŸå› **: éŸ³é¢‘æ–‡ä»¶æœªé¢„åŠ è½½

**è§£å†³**:

```typescript
// åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½
soundManager.preload(["api.success.post", "api.error.500"]);
```

### 3. éŸ³æ•ˆè¿‡äºé¢‘ç¹

**åŸå› **: èŠ‚æµé—´éš”å¤ªçŸ­

**è§£å†³**:

```typescript
// å¢åŠ èŠ‚æµé—´éš”
soundManager.updateConfig({
  categories: {
    api: { throttle: 2000 }, // 2 ç§’
  },
});
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [Web Audio API æ–‡æ¡£](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API)
- [ç³»ç»Ÿæ¶æ„](./architecture.md)
- [API å‚è€ƒ](./api-reference.md)
- [é…ç½®è¯´æ˜](./configuration.md)

---

**æœ€åæ›´æ–°**: 2025-10-01
